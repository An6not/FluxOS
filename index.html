<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AnnotCraft Platinum v20.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --mc-gui: #c6c6c6; --mc-shadow: rgba(0,0,0,0.5); }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; 
            background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            touch-action: none; -webkit-user-select: none;
        }

        /* Полная виньетка для погружения */
        #viewport-overlay {
            position: absolute; inset: 0; pointer-events: none; z-index: 500;
            background: radial-gradient(circle, transparent 40%, var(--mc-shadow) 150%);
        }

        /* Экраны меню */
        .screen { 
            position: absolute; inset: 0; z-index: 2000; display: flex; 
            flex-direction: column; align-items: center; justify-content: center; 
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), url('https://www.transparenttextures.com/patterns/carbon-fibre.png');
        }
        .panel { 
            background: var(--mc-gui); border: 4px solid #000; padding: 30px; 
            width: 320px; box-shadow: 10px 10px 0px #333; 
        }

        .mc-btn {
            background: #7c7c7c; border: 3px solid #000; color: #fff; padding: 15px;
            margin: 10px 0; width: 100%; font-weight: bold; cursor: pointer;
            box-shadow: inset 4px 4px #fff, inset -4px -4px #333; text-shadow: 2px 2px #000;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .mc-btn:active { transform: scale(0.98); box-shadow: inset -2px -2px #fff, inset 2px 2px #333; }

        /* HUD */
        #ui-hud { position: absolute; inset: 0; pointer-events: none; display: none; z-index: 1000; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before { content: ''; position: absolute; top: 11px; left: 0; width: 24px; height: 2px; background: #fff; mix-blend-mode: difference; }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 11px; width: 2px; height: 24px; background: #fff; mix-blend-mode: difference; }

        /* Компактный Хотбар */
        #hotbar { 
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); 
            display: flex; background: rgba(0,0,0,0.8); padding: 5px; border: 3px solid #111; pointer-events: auto; 
        }
        .slot { 
            width: 46px; height: 46px; border: 2px solid #555; margin: 0 3px; 
            transition: all 0.2s; position: relative; overflow: hidden;
        }
        .slot.active { border: 4px solid #fff; transform: translateY(-5px) scale(1.1); background: rgba(255,255,255,0.1); }
        .slot canvas { width: 100%; height: 100%; image-rendering: pixelated; }

        /* Органы управления */
        #joy-base { position: absolute; bottom: 50px; left: 50px; width: 110px; height: 110px; border: 4px solid rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; }
        #joy-stick { position: absolute; top: 30px; left: 30px; width: 50px; height: 50px; background: #fff; border-radius: 50%; opacity: 0.5; box-shadow: 0 0 15px #fff; }

        #action-btns { position: absolute; bottom: 50px; right: 40px; display: flex; flex-direction: column; gap: 20px; pointer-events: auto; }
        .circle-btn { 
            width: 85px; height: 85px; border-radius: 50%; background: rgba(0,0,0,0.6); 
            border: 3px solid #fff; color: #fff; display: flex; align-items: center; 
            justify-content: center; font-size: 12px; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #debug-panel { position: absolute; top: 15px; left: 15px; color: #fff; font-size: 10px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 4px; pointer-events: auto; }
        input { width: 100%; padding: 15px; margin: 10px 0; background: #222; color: #eee; border: 2px solid #000; outline: none; }
    </style>
</head>
<body>

    <div id="viewport-overlay"></div>

    <div id="m-main" class="screen">
        <h1 style="color:#fff; text-shadow: 4px 4px #000; font-size: 40px; margin-bottom: 20px;">ANNOT CRAFT</h1>
        <div class="panel">
            <button class="mc-btn" onclick="initEngine('single')">Одиночный мир</button>
            <button class="mc-btn" onclick="setScreen('multi')">Сетевая игра</button>
            <button class="mc-btn" onclick="toggleFull()">Полный экран</button>
            <p style="font-size:9px; color:#555; text-align:center;">BUILD 2026.02.18 / PLATINUM EDITION</p>
        </div>
    </div>

    <div id="m-multi" class="screen" style="display:none">
        <div class="panel">
            <h2 style="margin:0 0 15px 0;">MULTIPLAYER</h2>
            <input id="room-input" type="text" placeholder="ID Комнаты (напр. 777)">
            <button class="mc-btn" onclick="initEngine('host')">Создать Хост</button>
            <button class="mc-btn" onclick="initEngine('join')">Присоединиться</button>
            <button class="mc-btn" onclick="setScreen('main')">Назад</button>
        </div>
    </div>

    <div id="ui-hud">
        <div id="debug-panel">
            FPS: <span id="fps">60</span><br>
            XYZ: <span id="coords">0, 0, 0</span><br>
            CHUNKS: 1
        </div>
        
        <div id="crosshair"></div>

        <div id="hotbar">
            <div class="slot active" onclick="pickSlot(0)"><canvas id="c0"></canvas></div>
            <div class="slot" onclick="pickSlot(1)"><canvas id="c1"></canvas></div>
            <div class="slot" onclick="pickSlot(2)"><canvas id="c2"></canvas></div>
            <div class="slot" onclick="pickSlot(3)"><canvas id="c3"></canvas></div>
            <div class="slot" onclick="pickSlot(4)"><canvas id="c4"></canvas></div>
        </div>

        <div id="action-btns">
            <div class="circle-btn" style="border-color:#4CAF50;" onpointerdown="handleInteraction('place')">ПОСТАВИТЬ</div>
            <div class="circle-btn" style="border-color:#F44336;" onpointerdown="handleInteraction('break')">СЛОМАТЬ</div>
            <div class="circle-btn" style="width:60px; height:60px; align-self:center;" onpointerdown="playerJump()">ПРЫЖОК</div>
        </div>

        <div id="joy-base"><div id="joy-stick"></div></div>
    </div>

    <script>
        /** --- 1. ГЕНЕРАТОР ТЕКСТУР ВЫСОКОГО КАЧЕСТВА --- **/
        function generateDetailedTexture(blockType) {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');

            const drawGrain = (r, g, b, noiseStrength = 20) => {
                for(let i=0; i<16; i++) {
                    for(let j=0; j<16; j++) {
                        const n = (Math.random() - 0.5) * noiseStrength;
                        ctx.fillStyle = `rgb(${r+n},${g+n},${b+n})`;
                        ctx.fillRect(i, j, 1, 1);
                    }
                }
            };

            if(blockType === 'grass_top') {
                drawGrain(91, 168, 72, 30);
                // Добавляем "травинки"
                for(let k=0; k<10; k++) {
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(Math.random()*16, Math.random()*16, 1, 2);
                }
            } else if(blockType === 'dirt') {
                drawGrain(121, 85, 72, 15);
            } else if(blockType === 'grass_side') {
                drawGrain(121, 85, 72, 15);
                ctx.fillStyle = '#5ba848';
                ctx.fillRect(0, 0, 16, 6);
                for(let i=0; i<16; i++) if(Math.random()>0.4) ctx.fillRect(i, 6, 1, 1);
            } else if(blockType === 'stone') {
                drawGrain(110, 110, 110, 25);
                ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(0,0,16,1);
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,15,16,1);
            } else if(blockType === 'wood') {
                drawGrain(109, 76, 65, 10);
                ctx.fillStyle = '#4e342e'; ctx.fillRect(2,0,2,16); ctx.fillRect(12,0,2,16);
            } else if(blockType === 'leaf') {
                drawGrain(46, 125, 50, 40);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        const TEXTURES = {
            gt: generateDetailedTexture('grass_top'),
            gs: generateDetailedTexture('grass_side'),
            d: generateDetailedTexture('dirt'),
            s: generateDetailedTexture('stone'),
            w: generateDetailedTexture('wood'),
            l: generateDetailedTexture('leaf')
        };

        function getMaterial(id) {
            const m = (t) => new THREE.MeshLambertMaterial({ map: t });
            if(id === 0) return [m(TEXTURES.gs), m(TEXTURES.gs), m(TEXTURES.gt), m(TEXTURES.d), m(TEXTURES.gs), m(TEXTURES.gs)];
            if(id === 1) return m(TEXTURES.s);
            if(id === 2) return m(TEXTURES.w);
            if(id === 3) return new THREE.MeshLambertMaterial({ map: TEXTURES.l, transparent: true, opacity: 0.9 });
            return m(TEXTURES.s);
        }

        /** --- 2. ЯДРО ДВИЖКА --- **/
        let scene, camera, renderer, world = new Map(), clouds = [];
        let isGameRunning = false, isFP = true, activeSlot = 0;
        let playerPos = new THREE.Vector3(0, 10, 0), velocityY = 0;
        let rotationY = 0, rotationX = 0;
        let handMesh, steveMesh, selectionMesh, particleGroup = [];
        let joyState = {x:0, z:0}, touchData = {joyId: null, camId: null, lx: 0, ly: 0};
        let peerInstance, networkConn;

        function initEngine(mode) {
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            document.getElementById('ui-hud').style.display = 'block';
            isGameRunning = true;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Освещение
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(20, 100, 10);
            scene.add(sun);

            // Рамка выделения (Selection Box)
            selectionMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.02, 1.02, 1.02),
                new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.5 })
            );
            scene.add(selectionMesh);

            // Начальный мир
            for(let x=-14; x<=14; x++) {
                for(let z=-14; z<=14; z++) {
                    createBlock(x, 0, z, 0);
                    if(Math.random() > 0.99) { // Деревья
                        for(let h=1; h<5; h++) createBlock(x, h, z, 2);
                        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) createBlock(x+i, 5, z+j, 3);
                    }
                }
            }

            // Динамические облака
            for(let i=0; i<20; i++) {
                const c = new THREE.Mesh(new THREE.BoxGeometry(15, 1, 10), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.6}));
                c.position.set(Math.random()*200-100, 40, Math.random()*200-100);
                scene.add(c); clouds.push(c);
            }

            // Модель игрока и рука
            steveMesh = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.4), new THREE.MeshLambertMaterial({color: 0x00aaff}));
            steveMesh.add(body); scene.add(steveMesh); steveMesh.visible = false;

            handMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.7), getMaterial(0));
            camera.add(handMesh); scene.add(camera);
            handMesh.position.set(0.6, -0.6, -0.9);

            // Рендер иконок хотбара
            [TEXTURES.gt, TEXTURES.s, TEXTURES.w, TEXTURES.l, TEXTURES.gs].forEach((tex, i) => {
                const ctx = document.getElementById('c'+i).getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tex.image, 0, 0, 16, 16, 0, 0, 300, 150);
            });

            if(mode !== 'single') handleNetworking(mode);
            
            setupEventListeners();
            requestAnimationFrame(gameLoop);
        }

        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(world.has(key)) return;
            const b = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), getMaterial(type));
            b.position.set(x, y, z);
            b.typeId = type;
            scene.add(b);
            world.set(key, b);
        }

        /** --- 3. ПРОФЕССИОНАЛЬНАЯ ФИЗИКА И КОЛЛИЗИИ --- **/
        function checkCollision(pos) {
            const radius = 0.25; // Компактный хитбокс для прохода в двери/узкие места
            const heights = [0.2, 1.0, 1.6]; // Проверка на уровне ног, пояса и головы
            
            for(let h of heights) {
                const points = [
                    {x: pos.x - radius, z: pos.z - radius},
                    {x: pos.x + radius, z: pos.z - radius},
                    {x: pos.x - radius, z: pos.z + radius},
                    {x: pos.x + radius, z: pos.z + radius}
                ];
                for(let p of points) {
                    if(world.has(`${Math.round(p.x)},${Math.floor(pos.y + h)},${Math.round(p.z)}`)) return true;
                }
            }
            return false;
        }

        function gameLoop() {
            if(!isGameRunning) return;
            requestAnimationFrame(gameLoop);

            // Гравитация и Snap-Y
            velocityY -= 0.02;
            let nextY = playerPos.y + velocityY;
            if(!checkCollision({x: playerPos.x, y: nextY, z: playerPos.z})) {
                playerPos.y = nextY;
            } else {
                if(velocityY < 0) {
                    playerPos.y = Math.floor(playerPos.y + 0.01);
                    velocityY = 0;
                } else velocityY = 0;
            }

            // Движение с "мягким скольжением"
            const speed = 0.13;
            const dirX = (joyState.x * Math.cos(rotationY) + joyState.z * Math.sin(rotationY)) * speed;
            const dirZ = (joyState.z * Math.cos(rotationY) - joyState.x * Math.sin(rotationY)) * speed;

            if(!checkCollision({x: playerPos.x + dirX, y: playerPos.y, z: playerPos.z})) playerPos.x += dirX;
            if(!checkCollision({x: playerPos.x, y: playerPos.y, z: playerPos.z + dirZ})) playerPos.z += dirZ;

            // Частицы разрушения
            for(let i = particleGroup.length - 1; i >= 0; i--) {
                const p = particleGroup[i];
                p.position.add(p.vel);
                p.vel.y -= 0.01;
                p.life -= 0.03;
                p.scale.setScalar(p.life);
                if(p.life <= 0) { scene.remove(p); particleGroup.splice(i, 1); }
            }

            // Облака
            clouds.forEach(cl => { cl.position.x += 0.03; if(cl.position.x > 100) cl.position.x = -100; });

            // Raycaster для выделения блоков
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(Array.from(world.values()));
            if(hits.length > 0) {
                selectionMesh.visible = true;
                selectionMesh.position.copy(hits[0].object.position);
            } else selectionMesh.visible = false;

            // Камера и View Bobbing
            if(isFP) {
                const isMoving = Math.abs(joyState.x) > 0 || Math.abs(joyState.z) > 0;
                const bob = isMoving ? Math.sin(Date.now() * 0.01) * 0.05 : 0;
                camera.position.set(playerPos.x, playerPos.y + 1.6 + bob, playerPos.z);
                camera.rotation.set(rotationX, rotationY, 0, 'YXZ');
                handMesh.position.y = -0.6 + bob;
            } else {
                steveMesh.position.copy(playerPos);
                steveMesh.rotation.y = rotationY;
                camera.position.set(playerPos.x - Math.sin(rotationY)*4, playerPos.y + 3, playerPos.z - Math.cos(rotationY)*4);
                camera.lookAt(playerPos.x, playerPos.y + 1, playerPos.z);
            }

            // Update UI
            document.getElementById('coords').innerText = `${Math.floor(playerPos.x)}, ${Math.floor(playerPos.y)}, ${Math.floor(playerPos.z)}`;
            renderer.render(scene, camera);
        }

        /** --- 4. ИНТЕРАКЦИЯ И СЕТЬ --- **/
        function handleInteraction(type) {
            // Анимация удара
            handMesh.rotation.x = -0.5;
            setTimeout(() => handMesh.rotation.x = 0, 150);

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(Array.from(world.values()));

            if(hits.length > 0) {
                const hit = hits[0];
                const p = hit.object.position;

                if(type === 'break' && p.y !== 0) {
                    // Создание частиц
                    for(let i=0; i<12; i++) {
                        const pt = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({color: 0x555555}));
                        pt.position.copy(p);
                        pt.vel = new THREE.Vector3((Math.random()-0.5)*0.25, Math.random()*0.3, (Math.random()-0.5)*0.25);
                        pt.life = 1.0;
                        scene.add(pt); particleGroup.push(pt);
                    }
                    scene.remove(hit.object);
                    world.delete(`${p.x},${p.y},${p.z}`);
                    if(networkConn) networkConn.send({action: 'break', x:p.x, y:p.y, z:p.z});
                } else if(type === 'place') {
                    const newPos = hit.point.add(hit.face.normal.multiplyScalar(0.5)).floor();
                    createBlock(newPos.x, newPos.y, newPos.z, activeSlot);
                    if(networkConn) networkConn.send({action: 'place', x:newPos.x, y:newPos.y, z:newPos.z, type:activeSlot});
                }
            }
        }

        function setupEventListeners() {
            window.addEventListener('pointerdown', e => {
                if(e.target.closest('#ui-hud > div:not(#viewport-overlay)')) return;
                if(e.clientX < window.innerWidth / 2) touchData.joyId = e.pointerId;
                else { touchData.camId = e.pointerId; touchData.lx = e.clientX; touchData.ly = e.clientY; }
            });

            window.addEventListener('pointermove', e => {
                if(e.pointerId === touchData.joyId) {
                    const centerX = 105, centerY = window.innerHeight - 105;
                    const dx = e.clientX - centerX, dy = e.clientY - centerY;
                    const dist = Math.min(40, Math.sqrt(dx*dx + dy*dy));
                    const angle = Math.atan2(dy, dx);
                    joyState = { x: Math.cos(angle)*(dist/40), z: Math.sin(angle)*(dist/40) };
                    document.getElementById('joy-stick').style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                }
                if(e.pointerId === touchData.camId) {
                    rotationY -= (e.clientX - touchData.lx) * 0.007;
                    rotationX = Math.max(-1.5, Math.min(1.5, rotationX - (e.clientY - touchData.ly) * 0.007));
                    touchData.lx = e.clientX; touchData.ly = e.clientY;
                }
            });

            window.addEventListener('pointerup', e => {
                if(e.pointerId === touchData.joyId) { joyState = {x:0, z:0}; document.getElementById('joy-stick').style.transform = 'none'; touchData.joyId = null; }
                if(e.pointerId === touchData.camId) touchData.camId = null;
            });
        }

        /** --- 5. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ --- **/
        function pickSlot(i) {
            activeSlot = i;
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.slot')[i].classList.add('active');
            handMesh.material = getMaterial(activeSlot);
        }

        function playerJump() { if(velocityY === 0) velocityY = 0.28; }
        function setScreen(id) { document.querySelectorAll('.screen').forEach(s => s.style.display='none'); document.getElementById('m-'+id).style.display='flex'; }
        function toggleFull() { if(!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }

        function handleNetworking(mode) {
            const id = document.getElementById('room-input').value || 'room777';
            peerInstance = (mode === 'host') ? new Peer('annot_'+id) : new Peer();
            peerInstance.on('open', () => {
                if(mode === 'host') peerInstance.on('connection', c => { networkConn = c; syncNet(); });
                else { networkConn = peerInstance.connect('annot_'+id); syncNet(); }
            });
        }

        function syncNet() {
            networkConn.on('data', data => {
                if(data.action === 'break') {
                    const b = world.get(`${data.x},${data.y},${data.z}`);
                    if(b) { scene.remove(b); world.delete(`${data.x},${data.y},${data.z}`); }
                }
                if(data.action === 'place') createBlock(data.x, data.y, data.z, data.type);
            });
        }
    </script>
</body>
</html>
